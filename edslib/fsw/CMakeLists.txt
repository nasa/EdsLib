#
# LEW-19710-1, CCSDS SOIS Electronic Data Sheet Implementation
# 
# Copyright (c) 2020 United States Government as represented by
# the Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# CMake script for building the Electronic Data Sheet (EDS) Runtime library
#
# This is intended to be linked into the final executable binaries along with
# the output of the build tools.
#
# The EDS library is actually two separate libraries, a "basic" and a "full"
# version.  The basic version is the minimum required for all EDS operations
# and should be linked into all executables.  The full version has optional
# extra information, in particular the user-friendly names and the details
# of how to display the fields within message structures.   These are more
# memory hungry and typically would only be useful for UI or scripting
# applications.
#
# The following summarizes all products of this CMake recipe file:
#
# 1) Static library targets: "edslib_minimal" and "edslib_runtime_static"
#
#    These are the main FSW libraries and they are split per the rationale
#    above.  Only the minimal library is needed in all applications, the
#    full runtime can be linked additionally on an as-needed basis.
#
#    These are both marked "EXCLUDE_FROM_ALL" so they are not built unless
#    another executable target actually lists it in its link libraries.
#
#
# NOTE about CFE builds:
#
#  The CFE Software Bus (SB) depends on the functions in the "minimal"
#  EDS library to do proper message identification and command routing.
#  So only the "minimal" library is required for linking with CFE.
#
#  However in many circumstances (as long as the target isn't seriously
#  constrained on memory) it is better to include the full runtime that
#  includes functions for dealing with items by name.  This allows for
#  useful features like supporting on-board scripting languages
#  or conversion of Software Bus messages into other text-based formats.
#
#  This CMake recipe simply exposes the 2 library targets separately
#  and it is up to the CFE build to decide which one to link to.  This
#  determines which sets of EDS functions are available to cFS applications.
#  (The external variable CFE_SYSTEM_EDSDB_DYNAMIC_LINK affects this)
#
#
# 2) Shared library target: "edslib"
#
#    This is provided as a regular module library for general-purpose use.  This
#    contains the complete EdsLib API and is not split into two halves like the
#    static version.  This is dependent on the EDSLIB_BUILD_MODULE option.
#
#    Note this shared library target is not generated by default when building CFE,
#    because the CFE is expected statically link to the EDS library.  Furthermore,
#    some CFE targets (RTEMS) may not be able to build this target as a shared lib
#    anyway because they do not support real shared libs.
#
#    This could still be overridden by the user is a justification/benefit for having
#    CFE dynamically link to the EDS library instead of statically linking to it on
#    platforms where this is possible, but for now static linking is simpler and
#    eases deployment by having a single CFE core executable.
#
#
# 3) If part of a CFE mission (IS_CFS_MISSION_BUILD is TRUE) then a wrapper file is
#    created at:
#
#        ${MISSION_BINARY_DIR}/src/edslib_database_types.h
#
#    This is to support CFE builds where the generated C source files are that are
#    output into the same directory that need to include this file.
#
#

cmake_minimum_required(VERSION 2.8.8)
project(EDSLIB_FSW C)

enable_testing()

option(EDSLIB_BUILD_MODULE
    "Build a general-purpose EdsLib module for dynamically-linked applications"
    OFF)

include_directories(inc)

set(EDSLIB_BASE_SOURCES
    src/edslib_datatypedb_lookup.c
    src/edslib_datatypedb_iterator.c
    src/edslib_datatypedb_pack_unpack.c
    src/edslib_datatypedb_load_store.c
    src/edslib_datatypedb_constraints.c
    src/edslib_datatypedb_errorcontrol.c
    src/edslib_datatypedb_api.c
)

set(EDSLIB_RUNTIME_SOURCES
    src/edslib_displaydb_lookup.c
    src/edslib_displaydb_iterator.c
    src/edslib_displaydb_locate.c
    src/edslib_displaydb_stringconv.c
    src/edslib_displaydb_base64.c
    src/edslib_displaydb_api.c
    src/edslib_binding_objects.c
    src/edslib_msgid_api.c
)

# All files compiled here will have _EDSLIB_BUILD_ macro defined
# This allows for certain private header files to be included.
add_definitions(-D_EDSLIB_BUILD_)

# Propagate the value of EDSLIB_HAVE_LONG_DOUBLE:
# If the earlier check worked, then define a macro of the same name.
if (EDSLIB_HAVE_LONG_DOUBLE)
    add_definitions(-DEDSLIB_HAVE_LONG_DOUBLE)
endif (EDSLIB_HAVE_LONG_DOUBLE)

#
# The "edslib_minimal" static library target will always be defined.
#
# This is the library to handle the basic data type API
# such as querying sizes, inheritance, and encoding/decoding.
#
# This is always statically linked into CFE because SB depends on it.
# It is also available for applications or external tools to link
# with, however it is more likely that external tools will use the
# "runtime" library instead (below).  Note that the math library (m)
# is required only for encoding/decoding floating point values.
#
add_library(edslib_minimal STATIC EXCLUDE_FROM_ALL
    ${EDSLIB_BASE_SOURCES})
target_link_libraries(edslib_minimal m)

#
# The "edslib_runtime" static library target will always be defined.
#
# This is the library to handle the higher-level APIs
# such as names and terms for use in a user interface or binding
# to higher-level languages like JSON, Lua, or Python.
#
add_library(edslib_runtime_static STATIC EXCLUDE_FROM_ALL
    src/edslib_init.c
    ${EDSLIB_RUNTIME_SOURCES})
target_link_libraries(edslib_runtime_static edslib_minimal)



#
# The "edslib_runtime" PIC library target will always be defined.
#
# This is an all-inclusive library compiled as position-independent code (PIC)
# which allows the result to be linked into a shared library or module.
#
#
add_library(edslib_runtime_pic OBJECT EXCLUDE_FROM_ALL
    ${EDSLIB_BASE_SOURCES}
    ${EDSLIB_RUNTIME_SOURCES})
set_target_properties(edslib_runtime_pic PROPERTIES
    POSITION_INDEPENDENT_CODE TRUE)

if(EDSLIB_BUILD_MODULE)

    # For Non-CFS or local/standalone builds of this library, then also build
    # an all-inclusive module called "edslib" that other applications can load
    # dynamically.  This is generally identical to the static version but supports
    # applications like Python and Lua which may need to load the library dynamically
    # rather than statically linking it.  It is compiled as a single library
    # for convenience (splitting it is mainly for embedded use -- it is assumed that
    # general purpose processors using this dynamically-loaded version are not likely
    # to be memory-constrained, and probably need the full feature set as well).
    add_library(edslib MODULE src/edslib_init.c $<TARGET_OBJECTS:edslib_runtime_pic>)

    # By default install the "host" (all-inclusive) library into the lib directory
    install(TARGETS edslib DESTINATION lib)

endif(EDSLIB_BUILD_MODULE)


if(IS_CFS_MISSION_BUILD)

    # CFE component build
    # Sanity check -- the variable MISSION_BINARY_DIR should be defined
    # this indicates where to put all intermediate/output files
    if (NOT DEFINED MISSION_BINARY_DIR)
        message(FATAL_ERROR "MISSION_BINDARY_DIR must be defined when building within CFE")
    endif()

    # Create wrapper files around certain critical source files
    # This is so they will be guaranteed available at specific locations without
    # needing to pass the full path to each one
    file(WRITE ${EDSLIB_FSW_BINARY_DIR}/edslib_database_types.h.tmp
        "/* Generated wrapper based off the real source file location */\n"
        "#include \"${EDSLIB_FSW_SOURCE_DIR}/inc/edslib_database_types.h\"\n"
    )
    # Update the output only if different - avoid unnecessary rebuilds
    execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different
        ${EDSLIB_FSW_BINARY_DIR}/edslib_database_types.h.tmp
        ${MISSION_BINARY_DIR}/src/edslib_database_types.h
        RESULT_VARIABLE RES
    )
    file(REMOVE ${EDSLIB_FSW_BINARY_DIR}/edslib_database_types.h.tmp)

    if (NOT RES EQUAL 0)
        message(FATAL_ERROR "Unable to create wrapper file: code=${RES}")
    endif()

endif(IS_CFS_MISSION_BUILD)

# UT stubs should only be necesary on a CFS target build
if (ENABLE_UNIT_TESTS AND IS_CFS_ARCH_BUILD)
  add_subdirectory(ut-stubs)
endif (ENABLE_UNIT_TESTS AND IS_CFS_ARCH_BUILD)


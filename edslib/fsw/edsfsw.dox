/**

\defgroup fsw EDS runtime library

Runtime library for querying and using generated EDS data structures

\image html compilation.png "Overview of EDS workflow"

\section overview Overview

This module contains code for the runtime library that is compiled and linked into
the embedded executable, allowing the EDS data structures to be manipulated and queried
at runtime.

This library provides the routines that can assist with identification and
encoding/decoding of interface messages.

__Important__: All source code in this module, along with the intermediate/generated C structures
from the earlier build procedure must be compiled using the _target_ compiler toolchain if cross compiling.

\section org General Organization

The EDS library is split into two parts:

- The `basic` portion contains core API calls that operate only on the general type (i.e. integer/float/binary) 
  and size of structures

  Source files with `basic` in the filename are compiled into the basic EDS runtime library.
  
- The `full` portion provides API calls for additional information such as user-friendly names and 
  how to convert raw values into display form.  This library depends on the basic library, and is intended for 
  use by ground systems and debugging tools.  In general, embedded C code would _not_ need to link
  the full database objects or runtime library.  

  Source files with `full` in the filename are compiled into the full EDS runtime library.

Also, for each EDS file processed, the build tools will generate a corresponding `basic` and `full` runtime
component.  The runtime component is used with the respective EDS library.  In other words, the `basic` runtime 
library is limited to operating on data structures that are generated in the `basic` toolchain ouput.

\section build Building

The EDS library includes example build scripts for the CMake build system, which integrate easily into the Core
Flight Software (CFS) CMake build.  

For any other build system, one of two approaches can be used:
- Duplicate the logic in the example CMake build system into your build system of choice, or
- Treat EdsLib as an external library. Use the included CMake build scripts to build the EdsLib, and then
  export the artifacts to the larger build, just as with any other 3rd party library.
  
__Important Note__: The included CMake scripts build libraries, but they do _not_ perform any final linking or
make any assumptions about how the generated objects should be linked into the final executable.  It is up to 
the application developer/integrator to choose, and must directly specify, which generated EDS runtime artifacts 
should be linked into the final executable.  

\subsection impl Implementation ("impl") C files generated from toolchain

All C files generated from the toolchain should be considered C "implementation" blocks, not complete C source files.
These C files are not complete in that they do not contain the required \#`include` statements for all the types
used in the declarations.

This is intentional, as it allows the build system to specify the header file that should be used to define the 
object types.  It may optionally customize this file depending on the target CPU. 

\subsection compile Compiling the Implementation Objects

The example CMake build includes several CMake build functions, defined in the "edslib" CMakeLists.txt file:

- `eds_start_toplevel(TOPLEVEL_TGT)`
 
   Begins an EDS runtime database build target named `TOPLEVEL_TGT`.
   
- `eds_add_component(TOPLEVEL_TGT COMPONENT_NAME COMPONENT_EDS_FILES)`

   Adds a group of EDS files to the top level target as dependencies.  These will be linked into a library called
   `COMPONENT_NAME` and they become a dependency of the `TOPLEVEL_TGT` that was created by the eds_start_toplevel call. 
   
These functions create wrapper "C" files around the implementation blocks that were generated by the EDS 
parser tools.  These wrappers serve the following purposes:

- Include the necessary prerequisite header files (mainly `edslib_internal_types.h` for the EDS internal structure 
  types.  However, this could include extra files as necessary to customize or override certain types in a CPU or
  build specific manner.
  
- Makes a directly-compilable C source file in the file system for future steps

The example CMake build system will then compile these objects into static libraries as follows:

- `eds_add_component` will create a static library called `${COMPONENT_NAME}_eds`.  

   This library provides a `const` data object `${COMPONENT_NAME}_BASIC_EDS` that defines the __basic__ EDS 
   information for that single component, as well as a `${COMPONENT_NAME}_FULL_EDS` object that defines the 
   full/extended EDS information for the same component.

- `eds_start_toplevel` will create a static library called `${TOPLEVEL_TGT}_eds`.  

  This library provides a `const` array object called `${TOPLEVEL_TGT}_EDS_DATADICT_APPTBL` which contains 
  pointers to all _other_ basic EDS objects within that toplevel domain (i.e. added via "eds_add_component").  
  Similarly, it also provides `${TOPLEVEL_TGT}_EDS_NAMEDICT_APPTBL` which defines pointers to all other 
  full/extended EDS objects in the same top level domain.
  
__Important Note__: The static libraries are organized such that each object provided resides in a separate compilation
unit (.o file).  This way, only objects that are known "undefined" by the linker will actually be linked in. 
   
\subsection linking Linking the Objects

The included CMake scripts do not perform linking; all linking recipes are deferred to the user application, as this is
highly dependent on the nature of the application.  At least 3 variations are directly supportable via this library 
organization scheme:

- Statically linked ground support/control system

  A ground support system would typically link the _entire_ EDS library directly into the executable, so it can decipher
  all messages obtained in a user-friendly manner (using the correct "name" strings).  This also supports binding to other
  scripting languages such as Lua.
  
  To link the entire EDS, the main application simply needs to create an `extern` reference to the 
  `${TOPLEVEL_TGT}_EDS_DATADICT_APPTBL` and `${TOPLEVEL_TGT}_EDS_NAMEDICT_APPTBL` objects, and provide the `${TOPLEVEL_TGT}_eds`
  library on the final link line.  This library will in turn define the array (APPTBL) objects, which then depends on all 
  the other EDS objects as well.  Note that the CMake build script will include the rest of the libraries automatically, but
  if a custom build system is used this may need to be done manually.
  
  The ground system executable would also need to link the `edslib_full` library (which in turn depends on the `edslib_basic`
  library).
  
- Statically linked embedded system

  Generally, embedded systems do not require the user friendly name strings as the ground system would.  In this case, memory
  space can be saved by not linking any of the "full" database objects.  The user application creates an `extern` reference to 
  the `${TOPLEVEL_TGT}_EDS_DATADICT_APPTBL` only.  The application should link with the `${TOPLEVEL_TGT}_eds` just as the 
  ground system would, however only the `edslib_basic` library needs to be linked for the runtime library.
  
  In this case, the "full" objects will be pruned out by the linker as they do not satisfy any undefined references.
  
- Modular/Dynamically linked embedded system (e.g. CFE/CFS) 

  This is more complex than the statically linked examples.  In this case, each module/application would link only the EDS
  objects that it locally defines or requires.  At runtime, during the application load procedure, the EDS objects would
  be registered in a global runtime object.  The EDS library supports this function via the `EdsLib_Basic_AppDict_Register()`
  and `EdsLib_Basic_AppDict_Unregister()` API calls.
  
  This is effectively building the same database as the statically linked examples, but doing so dynamically at runtime.
  EDS API calls will only succeed for objects types that are currently registered.
  
  Only one module/application should link any single EDS object, including the runtime `edslib_basic` library.  If the
  runtime library is also dynamically linked into an application, this application must be loaded before any other 
  EDS-dependent applications are loaded.
  
__Other Possibilities__: This list is not intended to be complete, other combinations or approaches can be done.  The 
library structure allows considerable freedom by the application developers, including linking the "full" objects into 
the embedded code if necessary, or mixtures of statically-linked and dynamically-linked EDS objects.


\subsection examples Example application snippets

This section covers the recommended way to create a reference to EDS objects such that the correct subset of information
will be linked into the final executable.  

\subsubsection staticground Example statically linked ground application

This simple example covers a typical statically-linked application that uses an EDS top level object called "SAMPLE".
This code snippet, if included in any compilation unit, will create a global EDS object that references the
`SAMPLE_EDS_DATADICT_APPTBL` and `SAMPLE_EDS_NAMEDICT_APPTBL` objects produced by the EDS toolchain, which in turn 
references all other EDS objects within the "SAMPLE" domain: 

\code
/*
 * Instantiate an EDS global object that brings all elements together
 */
EdsLib_MissionObject_t SAMPLE_EDS =
{
      .AppTableSize = SAMPLE_EDS_INDEX_MAX,
      .AppDataTable = SAMPLE_EDS_DATADICT_APPTBL,
      .AppNameTable = SAMPLE_EDS_NAMEDICT_APPTBL
};
\endcode

The final application should be linked with `edslib_full` and `SAMPLE_eds` libraries, which in turn depend on
`edslib_basic` as well as all other component EDS libraries.

\subsubsection staticembed Example statically linked embeded C application

The statically linked embedded application is nearly identical to the ground application, except it has no need
for the user-friendly name information.  Therefore it can leave out the `SAMPLE_EDS_NAMEDICT_APPTBL` object:

\code
/*
 * Instantiate an EDS global object that brings all elements together
 */
EdsLib_MissionObject_t SAMPLE_EDS =
{
      .AppTableSize = SAMPLE_EDS_INDEX_MAX,
      .AppDataTable = SAMPLE_EDS_DATADICT_APPTBL
};
\endcode

The final application should be linked with `edslib_basic` and `SAMPLE_eds` libraries, which in turn depend on 
all other component EDS libraries.  However, all "full" objects will be pruned by the linker because they will 
not satisfy dependencies of this application.


\subsubsection dynamice Example dynamically linked C application

For a dynamically linked application, it simply must allocate space for the EDS tables, in the form
of an array of pointers.  It may be statically or dynamically allocated, and all pointers should be set to
NULL after initial allocation.

\code


/*
 * Instantiate an EDS global object that brings all elements together
 */

static EdsLib_DataDictionary_t *SAMPLE_RegTable[SAMPLE_EDS_INDEX_MAX] = { NULL };

EdsLib_MissionObject_t SAMPLE_EDS =
{
      .AppTableSize = SAMPLE_EDS_INDEX_MAX,
      .AppDataTable = SAMPLE_RegTable
};
\endcode

The final application does not necessary need to link with _any_ EDS libraries, it is up to the individual
applications to link with only the EDS libraries they actually define or require.  However, the application 
developer must ensure that only one application/module links any given EDS object, otherwise a "duplicate
object" error will be triggered by the runtime linker when the applications are loaded. 


\dir fsw
\ingroup fsw
 

*/

